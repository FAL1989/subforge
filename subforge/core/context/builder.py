#!/usr/bin/env python3
"""
Context Builder - Responsible for building context packages
"""

import logging
from typing import Optional, List, Dict, Any
from pathlib import Path

from .types import (
    ProjectContext,
    TechnicalContext,
    Example,
    Pattern,
    ValidationGate,
    ContextPackageDict,
)
from .validators import validate_context_package_data
from .exceptions import ContextGenerationError, ValidationError
from ..project_analyzer import ProjectProfile

logger = logging.getLogger(__name__)


class ContextPackage:
    """Complete context package for AI execution with strong typing"""

    def __init__(
        self,
        project_context: ProjectContext,
        technical_context: TechnicalContext,
        examples: List[Example],
        patterns: List[Pattern],
        validation_gates: List[ValidationGate],
        references: List[str],
        success_criteria: List[str],
    ):
        self.project_context = project_context
        self.technical_context = technical_context
        self.examples = examples
        self.patterns = patterns
        self.validation_gates = validation_gates
        self.references = references
        self.success_criteria = success_criteria

    def to_markdown(self) -> str:
        """Convert context package to structured markdown"""
        md = f"""# Context Package - {self.project_context.get('name', 'Unknown')}

## Project Context
{self._format_dict_as_markdown(self.project_context)}

## Technical Context
{self._format_dict_as_markdown(self.technical_context)}

## Code Examples & Patterns
{self._format_examples_as_markdown()}

## Validation Gates
{self._format_validation_gates_as_markdown()}

## Success Criteria
{self._format_list_as_markdown(self.success_criteria)}

## References
{self._format_list_as_markdown(self.references)}

Generated by SubForge Context Engineer
"""
        return md

    def _format_dict_as_markdown(self, data: dict) -> str:
        """Format dictionary as markdown list"""
        lines = []
        for key, value in data.items():
            if isinstance(value, list):
                lines.append(
                    f"- **{key.replace('_', ' ').title()}**: {', '.join(map(str, value))}"
                )
            else:
                lines.append(f"- **{key.replace('_', ' ').title()}**: {value}")
        return "\n".join(lines)

    def _format_examples_as_markdown(self) -> str:
        """Format examples as markdown sections"""
        if not self.examples:
            return "No specific examples available"

        sections = []
        for i, example in enumerate(self.examples, 1):
            sections.append(
                f"""### Example {i}: {example.get('title', 'Untitled')}
**Purpose**: {example.get('purpose', 'N/A')}
**Implementation**:
```{example.get('language', 'text')}
{example.get('code', 'No code provided')}
```
**Notes**: {example.get('notes', 'No additional notes')}
"""
            )
        return "\n".join(sections)

    def _format_validation_gates_as_markdown(self) -> str:
        """Format validation gates as executable checklist"""
        if not self.validation_gates:
            return "No validation gates defined"

        gates = []
        for gate in self.validation_gates:
            severity = gate.get('severity', 'medium')
            gate_type = gate.get('type', 'semantic')
            gates.append(
                f"""### {gate.get('name', 'Unnamed Gate')} [{severity.upper()}] ({gate_type})
- [ ] **Test**: {gate.get('test', 'No test defined')}
- [ ] **Command**: `{gate.get('command', 'No command')}`
- [ ] **Expected**: {gate.get('expected', 'No expectation set')}
- [ ] **On Failure**: {gate.get('on_failure', 'Manual investigation')}
"""
            )
        return "\n".join(gates)

    def _format_list_as_markdown(self, items: List[str]) -> str:
        """Format list as markdown bullet points"""
        if not items:
            return "None specified"
        return "\n".join(f"- {item}" for item in items)

    def to_dict(self) -> ContextPackageDict:
        """Convert to dictionary for serialization"""
        from datetime import datetime
        return ContextPackageDict(
            project_context=self.project_context,
            technical_context=self.technical_context,
            examples=self.examples,
            patterns=self.patterns,
            validation_gates=self.validation_gates,
            references=self.references,
            success_criteria=self.success_criteria,
            generated_at=datetime.now().isoformat(),
        )


class ContextBuilder:
    """Builder for creating context packages step by step"""

    def __init__(self):
        self._project_context: Optional[ProjectContext] = None
        self._technical_context: Optional[TechnicalContext] = None
        self._examples: List[Example] = []
        self._patterns: List[Pattern] = []
        self._validation_gates: List[ValidationGate] = []
        self._references: List[str] = []
        self._success_criteria: List[str] = []

    def with_project_context(self, profile: ProjectProfile) -> 'ContextBuilder':
        """Build project context from profile"""
        self._project_context = ProjectContext(
            name=profile.name,
            path=str(profile.path),
            architecture_pattern=profile.architecture_pattern.value,
            complexity_level=profile.complexity.value,
            languages=list(profile.technology_stack.languages),
            frameworks=list(profile.technology_stack.frameworks),
            databases=list(profile.technology_stack.databases),
            tools=list(profile.technology_stack.tools),
            team_size_estimate=profile.team_size_estimate,
            has_tests=profile.has_tests,
            has_ci_cd=profile.has_ci_cd,
            has_docker=profile.has_docker,
            file_count=profile.file_count,
            lines_of_code=profile.lines_of_code,
        )
        return self

    def with_technical_context(
        self, profile: ProjectProfile, phase: str
    ) -> 'ContextBuilder':
        """Build technical context for specific phase"""
        self._technical_context = TechnicalContext(
            phase=phase,
            primary_language=(
                next(iter(profile.technology_stack.languages))
                if profile.technology_stack.languages
                else "unknown"
            ),
            deployment_target="cloud" if profile.has_docker else "traditional",
            testing_strategy="comprehensive" if profile.has_tests else "basic",
            ci_cd_integration=profile.has_ci_cd,
        )
        
        # Add phase-specific context
        if phase == "analysis":
            self._technical_context["analysis_depth"] = (
                "deep" if profile.complexity.value != "simple" else "standard"
            )
            self._technical_context["discovery_areas"] = [
                "architecture",
                "dependencies",
                "patterns",
                "performance",
            ]
        elif phase == "selection":
            self._technical_context["template_criteria"] = self._get_template_criteria(profile)
            self._technical_context["customization_level"] = (
                "high" if profile.complexity.value == "complex" else "medium"
            )
        elif phase == "generation":
            self._technical_context["generation_targets"] = [
                "claude_md",
                "agents",
                "workflows",
                "commands",
            ]
            self._technical_context["customization_required"] = True
            self._technical_context["integration_complexity"] = profile.complexity.value
            
        return self

    def with_examples(self, examples: List[Example]) -> 'ContextBuilder':
        """Add examples to the context"""
        self._examples = examples
        return self

    def with_patterns(self, patterns: List[Pattern]) -> 'ContextBuilder':
        """Add patterns to the context"""
        self._patterns = patterns
        return self

    def with_validation_gates(self, gates: List[ValidationGate]) -> 'ContextBuilder':
        """Add validation gates to the context"""
        self._validation_gates = gates
        return self

    def with_references(self, references: List[str]) -> 'ContextBuilder':
        """Add references to the context"""
        self._references = references
        return self

    def with_success_criteria(self, criteria: List[str]) -> 'ContextBuilder':
        """Add success criteria to the context"""
        self._success_criteria = criteria
        return self

    def build(self) -> ContextPackage:
        """Build and validate the final context package"""
        if not self._project_context or not self._technical_context:
            raise ContextGenerationError(
                "Project and technical contexts are required"
            )

        try:
            # Validate all components
            validate_context_package_data(
                self._project_context,
                self._technical_context,
                self._examples,
                self._patterns,
                self._validation_gates
            )

            return ContextPackage(
                project_context=self._project_context,
                technical_context=self._technical_context,
                examples=self._examples,
                patterns=self._patterns,
                validation_gates=self._validation_gates,
                references=self._references,
                success_criteria=self._success_criteria,
            )
        except ValidationError as e:
            raise ContextGenerationError(f"Failed to build context package: {e}")

    def _get_template_criteria(self, profile: ProjectProfile) -> List[str]:
        """Get template selection criteria based on project profile"""
        criteria = []

        criteria.append(
            f"Support for {', '.join(profile.technology_stack.languages)} languages"
        )
        criteria.append(
            f"Compatible with {profile.architecture_pattern.value} architecture"
        )
        criteria.append(f"Appropriate for {profile.complexity.value} complexity")

        if profile.has_tests:
            criteria.append("Include comprehensive testing support")

        if profile.has_ci_cd:
            criteria.append("Support CI/CD integration")

        if profile.has_docker:
            criteria.append("Include containerization support")

        return criteria