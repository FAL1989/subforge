#!/usr/bin/env python3
"""
SubForge Communication System
Markdown-based communication protocol for isolated subagent context sharing
"""

import json
import yaml
from pathlib import Path
from typing import Dict, List, Optional, Any, Union
from dataclasses import dataclass, asdict
from enum import Enum
from datetime import datetime
import hashlib


class MessageType(Enum):
    ANALYSIS_REPORT = "analysis_report"
    TEMPLATE_SELECTION = "template_selection"
    CONFIGURATION = "configuration"
    VALIDATION_RESULT = "validation_result"
    DEPLOYMENT_PLAN = "deployment_plan"
    ERROR_REPORT = "error_report"
    STATUS_UPDATE = "status_update"


class MessagePriority(Enum):
    LOW = "low"
    NORMAL = "normal" 
    HIGH = "high"
    CRITICAL = "critical"


@dataclass
class CommunicationMessage:
    """Structured message for inter-subagent communication"""
    message_id: str
    sender: str
    recipient: Optional[str]  # None for broadcast messages
    message_type: MessageType
    priority: MessagePriority
    timestamp: str
    subject: str
    content: Dict[str, Any]
    metadata: Dict[str, Any]
    
    def to_dict(self) -> Dict:
        return {
            "message_id": self.message_id,
            "sender": self.sender,
            "recipient": self.recipient,
            "message_type": self.message_type.value,
            "priority": self.priority.value,
            "timestamp": self.timestamp,
            "subject": self.subject,
            "content": self.content,
            "metadata": self.metadata
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'CommunicationMessage':
        return cls(
            message_id=data["message_id"],
            sender=data["sender"],
            recipient=data.get("recipient"),
            message_type=MessageType(data["message_type"]),
            priority=MessagePriority(data["priority"]),
            timestamp=data["timestamp"],
            subject=data["subject"],
            content=data["content"],
            metadata=data["metadata"]
        )


class MarkdownFormatter:
    """Formats communication messages as structured markdown"""
    
    @staticmethod
    def format_message(message: CommunicationMessage) -> str:
        """Format a communication message as markdown"""
        content = f"""# {message.subject}

## Message Information
- **ID**: `{message.message_id}`
- **From**: `{message.sender}`
- **To**: `{message.recipient or 'ALL'}`
- **Type**: `{message.message_type.value}`
- **Priority**: `{message.priority.value}`
- **Timestamp**: `{message.timestamp}`

## Content

"""
        
        # Format content based on message type
        if message.message_type == MessageType.ANALYSIS_REPORT:
            content += MarkdownFormatter._format_analysis_content(message.content)
        elif message.message_type == MessageType.TEMPLATE_SELECTION:
            content += MarkdownFormatter._format_selection_content(message.content)
        elif message.message_type == MessageType.CONFIGURATION:
            content += MarkdownFormatter._format_configuration_content(message.content)
        elif message.message_type == MessageType.VALIDATION_RESULT:
            content += MarkdownFormatter._format_validation_content(message.content)
        elif message.message_type == MessageType.DEPLOYMENT_PLAN:
            content += MarkdownFormatter._format_deployment_content(message.content)
        elif message.message_type == MessageType.ERROR_REPORT:
            content += MarkdownFormatter._format_error_content(message.content)
        else:
            content += MarkdownFormatter._format_generic_content(message.content)
        
        # Add metadata section
        if message.metadata:
            content += "\n## Metadata\n\n"
            content += "```yaml\n"
            content += yaml.dump(message.metadata, default_flow_style=False)
            content += "```\n"
        
        content += f"\n---\n*Generated by SubForge Communication System*\n"
        
        return content
    
    @staticmethod
    def _format_analysis_content(content: Dict[str, Any]) -> str:
        """Format project analysis content"""
        md = "### Project Analysis\n\n"
        
        if "project_profile" in content:
            profile = content["project_profile"]
            md += f"**Project**: {profile.get('name', 'Unknown')}\n"
            md += f"**Architecture**: {profile.get('architecture_pattern', 'Unknown')}\n"
            md += f"**Complexity**: {profile.get('complexity', 'Unknown')}\n\n"
            
            # Technology stack
            if "technology_stack" in profile:
                tech = profile["technology_stack"]
                md += "#### Technology Stack\n"
                if tech.get("languages"):
                    md += f"- **Languages**: {', '.join(tech['languages'])}\n"
                if tech.get("frameworks"):
                    md += f"- **Frameworks**: {', '.join(tech['frameworks'])}\n"
                if tech.get("databases"):
                    md += f"- **Databases**: {', '.join(tech['databases'])}\n"
                if tech.get("tools"):
                    md += f"- **Tools**: {', '.join(tech['tools'])}\n"
                md += "\n"
            
            # Recommendations
            if "recommended_subagents" in profile:
                md += "#### Recommended Subagents\n"
                for agent in profile["recommended_subagents"]:
                    md += f"- `{agent}`\n"
                md += "\n"
        
        if "analysis_summary" in content:
            md += f"#### Summary\n{content['analysis_summary']}\n\n"
        
        return md
    
    @staticmethod
    def _format_selection_content(content: Dict[str, Any]) -> str:
        """Format template selection content"""
        md = "### Template Selection Results\n\n"
        
        if "selected_templates" in content:
            templates = content["selected_templates"]
            md += f"**Selected**: {len(templates)} templates\n\n"
            
            for template in templates:
                if isinstance(template, dict):
                    name = template.get("name", "Unknown")
                    score = template.get("score", 0)
                    reason = template.get("reason", "No reason provided")
                    md += f"#### {name}\n"
                    md += f"- **Match Score**: {score:.2f}\n"
                    md += f"- **Reason**: {reason}\n\n"
                else:
                    md += f"- `{template}`\n"
        
        if "template_customizations" in content:
            md += "#### Customizations\n"
            customizations = content["template_customizations"]
            for template, custom in customizations.items():
                md += f"**{template}**:\n"
                for key, value in custom.items():
                    md += f"- {key}: `{value}`\n"
                md += "\n"
        
        return md
    
    @staticmethod
    def _format_configuration_content(content: Dict[str, Any]) -> str:
        """Format configuration content"""
        md = "### Configuration\n\n"
        
        if "claude_md_content" in content:
            md += "#### CLAUDE.md Configuration\n"
            md += "```markdown\n"
            md += content["claude_md_content"]
            md += "\n```\n\n"
        
        if "generated_agents" in content:
            md += "#### Generated Subagents\n"
            for agent in content["generated_agents"]:
                if isinstance(agent, dict):
                    name = agent.get("name", "Unknown")
                    tools = agent.get("tools", [])
                    customized = agent.get("customized", False)
                    md += f"- **{name}**\n"
                    md += f"  - Customized: {'Yes' if customized else 'No'}\n"
                    md += f"  - Tools: {', '.join(tools)}\n"
                else:
                    md += f"- {agent}\n"
            md += "\n"
        
        if "workflows" in content:
            md += "#### Generated Workflows\n"
            for workflow in content["workflows"]:
                if isinstance(workflow, dict):
                    name = workflow.get("name", "Unknown")
                    steps = workflow.get("steps", [])
                    md += f"- **{name}**: {' â†’ '.join(steps)}\n"
                else:
                    md += f"- {workflow}\n"
            md += "\n"
        
        if "commands" in content:
            md += "#### Custom Commands\n"
            commands = content["commands"]
            for cmd, desc in commands.items():
                md += f"- `{cmd}`: {desc}\n"
            md += "\n"
        
        return md
    
    @staticmethod
    def _format_validation_content(content: Dict[str, Any]) -> str:
        """Format validation results content"""
        md = "### Validation Results\n\n"
        
        if "validation_results" in content:
            results = content["validation_results"]
            md += "#### Validation Checks\n"
            for check, status in results.items():
                emoji = "âœ…" if status == "passed" else "âŒ" if status == "failed" else "âš ï¸"
                md += f"- {emoji} **{check.replace('_', ' ').title()}**: {status}\n"
            md += "\n"
        
        if "deployment_readiness" in content:
            ready = content["deployment_readiness"]
            emoji = "ðŸš€" if ready else "ðŸš«"
            md += f"{emoji} **Deployment Ready**: {'Yes' if ready else 'No'}\n\n"
        
        if "rollback_plan" in content:
            md += f"#### Rollback Plan\n{content['rollback_plan']}\n\n"
        
        if "recommendations" in content:
            md += "#### Recommendations\n"
            for rec in content["recommendations"]:
                md += f"- {rec}\n"
            md += "\n"
        
        return md
    
    @staticmethod
    def _format_deployment_content(content: Dict[str, Any]) -> str:
        """Format deployment plan content"""
        md = "### Deployment Plan\n\n"
        
        if "deployment_steps" in content:
            md += "#### Steps\n"
            for i, step in enumerate(content["deployment_steps"], 1):
                md += f"{i}. {step}\n"
            md += "\n"
        
        if "deployment_location" in content:
            md += f"**Target Location**: `{content['deployment_location']}`\n\n"
        
        if "estimated_time" in content:
            md += f"**Estimated Time**: {content['estimated_time']}\n\n"
        
        return md
    
    @staticmethod
    def _format_error_content(content: Dict[str, Any]) -> str:
        """Format error report content"""
        md = "### Error Report\n\n"
        
        if "error_type" in content:
            md += f"**Type**: `{content['error_type']}`\n"
        
        if "error_message" in content:
            md += f"**Message**: {content['error_message']}\n\n"
        
        if "stack_trace" in content:
            md += "#### Stack Trace\n"
            md += "```\n"
            md += content["stack_trace"]
            md += "\n```\n\n"
        
        if "suggested_fixes" in content:
            md += "#### Suggested Fixes\n"
            for fix in content["suggested_fixes"]:
                md += f"- {fix}\n"
            md += "\n"
        
        return md
    
    @staticmethod
    def _format_generic_content(content: Dict[str, Any]) -> str:
        """Format generic content as YAML"""
        return "```yaml\n" + yaml.dump(content, default_flow_style=False) + "```\n"


class CommunicationChannel:
    """Manages communication channel for a specific workflow"""
    
    def __init__(self, channel_dir: Path):
        self.channel_dir = channel_dir
        self.channel_dir.mkdir(parents=True, exist_ok=True)
        
        # Create channel structure
        self.messages_dir = self.channel_dir / "messages"
        self.broadcasts_dir = self.channel_dir / "broadcasts"
        self.archive_dir = self.channel_dir / "archive"
        
        self.messages_dir.mkdir(exist_ok=True)
        self.broadcasts_dir.mkdir(exist_ok=True)
        self.archive_dir.mkdir(exist_ok=True)
        
        self.formatter = MarkdownFormatter()
    
    def send_message(self, sender: str, subject: str, content: Dict[str, Any],
                    recipient: Optional[str] = None, 
                    message_type: MessageType = MessageType.STATUS_UPDATE,
                    priority: MessagePriority = MessagePriority.NORMAL) -> str:
        """Send a message through the communication channel"""
        
        # Generate message ID
        message_id = self._generate_message_id(sender, subject)
        
        # Create message
        message = CommunicationMessage(
            message_id=message_id,
            sender=sender,
            recipient=recipient,
            message_type=message_type,
            priority=priority,
            timestamp=datetime.now().isoformat(),
            subject=subject,
            content=content,
            metadata={
                "channel_dir": str(self.channel_dir),
                "generated_by": "SubForge Communication System"
            }
        )
        
        # Save message to appropriate directory
        if recipient:
            # Direct message
            message_dir = self.messages_dir / recipient
            message_dir.mkdir(exist_ok=True)
            message_file = message_dir / f"{message_id}.md"
        else:
            # Broadcast message
            message_file = self.broadcasts_dir / f"{message_id}.md"
        
        # Write message as markdown
        with open(message_file, 'w', encoding='utf-8') as f:
            f.write(self.formatter.format_message(message))
        
        # Also save JSON version for programmatic access
        json_file = message_file.with_suffix('.json')
        with open(json_file, 'w', encoding='utf-8') as f:
            json.dump(message.to_dict(), f, indent=2)
        
        return message_id
    
    def get_messages(self, recipient: Optional[str] = None, 
                    message_type: Optional[MessageType] = None) -> List[CommunicationMessage]:
        """Retrieve messages for a specific recipient or all broadcast messages"""
        messages = []
        
        if recipient:
            # Get direct messages
            recipient_dir = self.messages_dir / recipient
            if recipient_dir.exists():
                messages.extend(self._load_messages_from_dir(recipient_dir, message_type))
        
        # Always include broadcast messages
        messages.extend(self._load_messages_from_dir(self.broadcasts_dir, message_type))
        
        # Sort by timestamp
        messages.sort(key=lambda m: m.timestamp)
        
        return messages
    
    def _load_messages_from_dir(self, directory: Path, 
                               message_type: Optional[MessageType] = None) -> List[CommunicationMessage]:
        """Load messages from a directory"""
        messages = []
        
        for json_file in directory.glob("*.json"):
            try:
                with open(json_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                message = CommunicationMessage.from_dict(data)
                
                # Filter by message type if specified
                if message_type is None or message.message_type == message_type:
                    messages.append(message)
                    
            except Exception as e:
                print(f"Warning: Could not load message {json_file}: {e}")
        
        return messages
    
    def archive_messages(self, older_than_days: int = 7) -> int:
        """Archive old messages to reduce clutter"""
        archived_count = 0
        cutoff_time = datetime.now().timestamp() - (older_than_days * 24 * 60 * 60)
        
        # Archive messages from all directories
        for directory in [self.messages_dir, self.broadcasts_dir]:
            if directory.exists():
                archived_count += self._archive_messages_from_dir(directory, cutoff_time)
        
        return archived_count
    
    def _archive_messages_from_dir(self, directory: Path, cutoff_time: float) -> int:
        """Archive messages from a specific directory"""
        archived_count = 0
        
        for json_file in directory.rglob("*.json"):
            if json_file.stat().st_mtime < cutoff_time:
                # Move to archive
                relative_path = json_file.relative_to(directory)
                archive_path = self.archive_dir / relative_path
                archive_path.parent.mkdir(parents=True, exist_ok=True)
                
                # Move both JSON and markdown files
                json_file.rename(archive_path)
                md_file = json_file.with_suffix('.md')
                if md_file.exists():
                    md_file.rename(archive_path.with_suffix('.md'))
                
                archived_count += 1
        
        return archived_count
    
    def _generate_message_id(self, sender: str, subject: str) -> str:
        """Generate unique message ID"""
        content = f"{sender}_{subject}_{datetime.now().isoformat()}"
        return hashlib.md5(content.encode()).hexdigest()[:12]
    
    def get_channel_summary(self) -> Dict[str, Any]:
        """Get summary of channel activity"""
        summary = {
            "total_messages": 0,
            "broadcast_messages": 0,
            "direct_messages": 0,
            "message_types": {},
            "active_recipients": set(),
            "latest_activity": None
        }
        
        # Count broadcast messages
        if self.broadcasts_dir.exists():
            broadcast_count = len(list(self.broadcasts_dir.glob("*.json")))
            summary["broadcast_messages"] = broadcast_count
            summary["total_messages"] += broadcast_count
        
        # Count direct messages
        if self.messages_dir.exists():
            for recipient_dir in self.messages_dir.iterdir():
                if recipient_dir.is_dir():
                    summary["active_recipients"].add(recipient_dir.name)
                    msg_count = len(list(recipient_dir.glob("*.json")))
                    summary["direct_messages"] += msg_count
                    summary["total_messages"] += msg_count
        
        # Get message type distribution
        all_messages = self.get_messages()
        for message in all_messages:
            msg_type = message.message_type.value
            summary["message_types"][msg_type] = summary["message_types"].get(msg_type, 0) + 1
            
            # Track latest activity
            if summary["latest_activity"] is None or message.timestamp > summary["latest_activity"]:
                summary["latest_activity"] = message.timestamp
        
        summary["active_recipients"] = list(summary["active_recipients"])
        return summary


# Utility functions for common communication patterns
def send_analysis_report(channel: CommunicationChannel, sender: str, 
                        project_profile: Dict[str, Any]) -> str:
    """Send a project analysis report"""
    return channel.send_message(
        sender=sender,
        subject="Project Analysis Complete",
        content={"project_profile": project_profile},
        message_type=MessageType.ANALYSIS_REPORT,
        priority=MessagePriority.HIGH
    )


def send_template_selection(channel: CommunicationChannel, sender: str,
                           selected_templates: List[Dict[str, Any]]) -> str:
    """Send template selection results"""
    return channel.send_message(
        sender=sender,
        subject="Template Selection Results",
        content={"selected_templates": selected_templates},
        message_type=MessageType.TEMPLATE_SELECTION,
        priority=MessagePriority.HIGH
    )


def send_configuration(channel: CommunicationChannel, sender: str,
                      recipient: str, configuration: Dict[str, Any]) -> str:
    """Send configuration to specific recipient"""
    return channel.send_message(
        sender=sender,
        recipient=recipient,
        subject=f"Configuration from {sender}",
        content=configuration,
        message_type=MessageType.CONFIGURATION,
        priority=MessagePriority.NORMAL
    )


def send_error_report(channel: CommunicationChannel, sender: str,
                     error_message: str, error_details: Dict[str, Any]) -> str:
    """Send an error report"""
    content = {
        "error_message": error_message,
        **error_details
    }
    
    return channel.send_message(
        sender=sender,
        subject=f"Error in {sender}",
        content=content,
        message_type=MessageType.ERROR_REPORT,
        priority=MessagePriority.CRITICAL
    )


# CLI interface for testing
def main():
    """CLI interface for testing the communication system"""
    import argparse
    
    parser = argparse.ArgumentParser(description="SubForge Communication System Test")
    parser.add_argument("command", choices=["send", "list", "summary"], help="Command to execute")
    parser.add_argument("--channel", required=True, help="Communication channel directory")
    parser.add_argument("--sender", help="Message sender (for send command)")
    parser.add_argument("--recipient", help="Message recipient (for send command)")
    parser.add_argument("--subject", help="Message subject (for send command)")
    parser.add_argument("--content", help="Message content as JSON (for send command)")
    
    args = parser.parse_args()
    
    channel = CommunicationChannel(Path(args.channel))
    
    if args.command == "send":
        if not all([args.sender, args.subject, args.content]):
            print("Error: send command requires --sender, --subject, and --content")
            return
        
        try:
            content = json.loads(args.content)
            message_id = channel.send_message(
                sender=args.sender,
                recipient=args.recipient,
                subject=args.subject,
                content=content
            )
            print(f"Message sent with ID: {message_id}")
            
        except json.JSONDecodeError:
            print("Error: --content must be valid JSON")
    
    elif args.command == "list":
        messages = channel.get_messages(args.recipient)
        for message in messages:
            print(f"[{message.timestamp}] {message.sender} -> {message.recipient or 'ALL'}: {message.subject}")
    
    elif args.command == "summary":
        summary = channel.get_channel_summary()
        print(f"Channel Summary:")
        print(f"  Total Messages: {summary['total_messages']}")
        print(f"  Broadcast Messages: {summary['broadcast_messages']}")
        print(f"  Direct Messages: {summary['direct_messages']}")
        print(f"  Active Recipients: {', '.join(summary['active_recipients'])}")
        print(f"  Latest Activity: {summary['latest_activity']}")
        
        if summary['message_types']:
            print("  Message Types:")
            for msg_type, count in summary['message_types'].items():
                print(f"    {msg_type}: {count}")


if __name__ == "__main__":
    main()