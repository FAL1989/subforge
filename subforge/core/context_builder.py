#!/usr/bin/env python3
"""
Context Builder for SubForge
Builds CLAUDE.md hierarchy and .claude/ structure from extracted knowledge
Creates proper Claude Code context files based on official patterns
"""

import os
import json
from pathlib import Path
from typing import Dict, List, Optional, Any
from dataclasses import dataclass
from datetime import datetime

from .knowledge_extractor import (
    ProjectInfo, Command, Workflow, Module, Architecture
)


@dataclass 
class CommandFile:
    """Represents a command file in .claude/commands/"""
    name: str
    content: str
    path: Path


@dataclass
class AgentFile:
    """Represents an agent file in .claude/agents/"""
    name: str
    content: str
    path: Path


@dataclass
class WorkflowFile:
    """Represents a workflow file in .claude/workflows/"""
    name: str
    content: str
    path: Path


class ContextBuilder:
    """
    Builds Claude Code context files from extracted project knowledge
    Following official Claude Code patterns
    """
    
    def __init__(self, project_path: str = None):
        """Initialize with project path"""
        self.project_path = Path(project_path or os.getcwd())
        self.claude_dir = self.project_path / ".claude"
        
    def build_root_claude_md(self, 
                           project_info: ProjectInfo,
                           modules: List[Module],
                           commands: Dict[str, Command]) -> str:
        """
        Creates main CLAUDE.md with project overview
        This goes in project root, NOT in .claude/
        """
        
        # Format languages and frameworks
        languages = ', '.join(project_info.languages) if project_info.languages else 'Not detected'
        frameworks = ', '.join(project_info.frameworks) if project_info.frameworks else 'Not detected'
        databases = ', '.join(project_info.databases) if project_info.databases else 'Not detected'
        
        # Format key modules
        module_list = []
        for module in modules[:10]:  # Limit to top 10 modules
            module_list.append(f"- **{module.name}**: {module.description}")
        modules_section = '\n'.join(module_list) if module_list else "- No significant modules detected"
        
        # Format main commands by category
        command_categories = {}
        for cmd_name, cmd in commands.items():
            if cmd.category not in command_categories:
                command_categories[cmd.category] = []
            command_categories[cmd.category].append((cmd_name, cmd))
        
        commands_section = []
        for category in ['dev', 'test', 'build', 'deploy']:
            if category in command_categories:
                commands_section.append(f"\n### {category.capitalize()} Commands")
                for cmd_name, cmd in command_categories[category][:3]:  # Top 3 per category
                    commands_section.append(f"- `{cmd.command}` - {cmd.description}")
        
        commands_text = '\n'.join(commands_section) if commands_section else "See .claude/commands/ for all commands"
        
        # Build the CLAUDE.md content
        claude_md = f"""# {project_info.name}

## Overview
{project_info.description or 'Project description not found. Please update this section.'}

## Technology Stack
- **Languages**: {languages}
- **Frameworks**: {frameworks}  
- **Databases**: {databases}

## Architecture
{project_info.architecture}

## Project Structure
{modules_section}

## Quick Start
{self._generate_quick_start(project_info, commands)}

## Key Commands
{commands_text}

For all available commands, see `.claude/commands/`

## Development Guidelines

### Conventions
{project_info.conventions}

### Working with Modules
Each major module has its own CLAUDE.md file with specific context:
{self._list_module_contexts(modules)}

### Testing
{self._generate_testing_section(commands)}

### Deployment
{self._generate_deployment_section(commands)}

## Project Context

### Repository
{project_info.repository or 'Repository URL not found'}

### Version
{project_info.version or 'Version not specified'}

## Additional Resources
- See `.claude/commands/` for all available commands
- See `.claude/workflows/` for standard workflows
- See `.claude/agents/` for specialized AI agents

---
*Generated by SubForge on {datetime.now().strftime('%Y-%m-%d %H:%M')} UTC-3 SÃ£o Paulo*
*This file provides context for Claude Code. Update as needed.*
"""
        
        return claude_md
    
    def build_module_claude_md(self, module: Module, project_info: ProjectInfo) -> str:
        """
        Creates subdirectory CLAUDE.md for specific module context
        These go in module directories, not in .claude/
        """
        
        # Format key files
        key_files = '\n'.join(f"- `{f}`" for f in module.key_files) if module.key_files else "- No key files identified"
        
        # Format dependencies
        deps = ', '.join(module.dependencies[:10]) if module.dependencies else "No specific dependencies"
        
        # Generate module-specific content
        claude_md = f"""# {module.name} Module

## Overview
{module.description}

## Module Context
This module is part of the {project_info.name} project.

## Structure

### Key Files
{key_files}

### Dependencies
{deps}

## Testing
{module.test_command or f'Run project tests that cover this module'}

## Module-Specific Guidelines

### Conventions
{module.conventions or f'Follow project-wide conventions from root CLAUDE.md'}

### Common Tasks
{self._generate_module_tasks(module)}

### Integration Points
{self._generate_integration_points(module)}

## Development Notes
{self._generate_development_notes(module)}

---
*Module context for {module.name}*
*Part of {project_info.name} project*
"""
        
        return claude_md
    
    def build_command_files(self, commands: Dict[str, Command]) -> List[CommandFile]:
        """
        Creates .claude/commands/*.md files
        Each command gets its own file for slash command support
        """
        command_files = []
        
        for name, cmd in commands.items():
            # Create clean filename (remove special characters)
            filename = name.replace(':', '-').replace('/', '-')
            
            # Determine if command needs parameters
            needs_params = self._analyze_command_parameters(cmd.command)
            
            content = f"""---
name: {name}
description: {cmd.description}
category: {cmd.category}
source: {cmd.source}
---

# /{name} Command

## Description
{cmd.description}

## Usage
```bash
{cmd.command}
```

## Category
{cmd.category.capitalize()}

## Source
Found in: `{cmd.source}`

{self._generate_command_details(cmd)}

{self._generate_command_examples(name, cmd, needs_params)}

## Related Commands
{self._find_related_commands(name, cmd, commands)}
"""
            
            command_files.append(CommandFile(
                name=filename,
                content=content,
                path=self.claude_dir / "commands" / f"{filename}.md"
            ))
        
        return command_files
    
    def build_agent_files(self, modules: List[Module], project_info: ProjectInfo) -> List[AgentFile]:
        """
        Creates domain-specific agents based on actual modules
        Not generic templates, but specific to this project's structure
        """
        agent_files = []
        
        for module in modules:
            # Generate agent name from module
            agent_name = f"{module.name}-specialist"
            
            # Determine appropriate tools based on module characteristics
            tools = self._determine_agent_tools(module)
            
            # Generate agent prompt based on actual module context
            content = f"""---
name: {agent_name}
tools: {', '.join(tools)}
model: sonnet
context: {module.path.relative_to(self.project_path).as_posix()}/
---

You are a specialist for the {module.name} module in the {project_info.name} project.

## Your Domain
You are responsible for the code in `{module.path.relative_to(self.project_path).as_posix()}/`

## Module Overview  
{module.description}

## Key Files You Manage
{chr(10).join(f'- {f}' for f in module.key_files)}

## Dependencies You Work With
{', '.join(module.dependencies[:10]) if module.dependencies else 'Standard project dependencies'}

## Your Responsibilities
{self._generate_agent_responsibilities(module)}

## Testing
{module.test_command or 'Follow project testing conventions'}

## Guidelines
1. Maintain consistency with existing patterns in this module
2. Follow the project's architecture: {project_info.architecture}
3. Use the established tech stack: {', '.join(project_info.frameworks[:5])}
4. Ensure changes are tested{f' using: {module.test_command}' if module.test_command else ''}
5. Document significant changes in module documentation

## Integration Context
- This module is part of a {project_info.architecture} architecture
- Coordinate with other modules through established interfaces
- Follow project-wide conventions from root CLAUDE.md

## Common Operations
{self._generate_agent_operations(module)}
"""
            
            agent_files.append(AgentFile(
                name=agent_name,
                content=content,
                path=self.claude_dir / "agents" / f"{agent_name}.md"
            ))
        
        # Also create a general project coordinator agent
        coordinator_content = f"""---
name: project-coordinator
tools: Read, Write, Edit, Bash, Grep, Glob
model: sonnet
---

You coordinate work across the entire {project_info.name} project.

## Project Overview
{project_info.description}

## Architecture
{project_info.architecture}

## Technology Stack
- Languages: {', '.join(project_info.languages)}
- Frameworks: {', '.join(project_info.frameworks)}
- Databases: {', '.join(project_info.databases)}

## Key Modules
{chr(10).join(f'- {m.name}: {m.description}' for m in modules[:10])}

## Your Role
You handle cross-cutting concerns and coordinate between different modules:
- Architectural decisions and patterns
- Cross-module integrations
- Project-wide refactoring
- Dependency management
- Build and deployment configuration
- Documentation updates

## Guidelines
1. Maintain architectural consistency
2. Ensure modules remain properly decoupled
3. Coordinate breaking changes across modules
4. Keep project documentation up to date
5. Monitor overall project health

## Available Specialists
You can delegate module-specific work to:
{chr(10).join(f'- @{m.name}-specialist' for m in modules[:10])}
"""
        
        agent_files.append(AgentFile(
            name="project-coordinator",
            content=coordinator_content,
            path=self.claude_dir / "agents" / "project-coordinator.md"
        ))
        
        return agent_files
    
    def build_workflow_files(self, workflows: Dict[str, Workflow], commands: Dict[str, Command]) -> List[WorkflowFile]:
        """
        Creates .claude/workflows/*.md files
        Based on extracted CI/CD and documented workflows
        """
        workflow_files = []
        
        for name, workflow in workflows.items():
            # Sanitize workflow name for filename
            safe_name = name.replace('/', '-').replace('\\', '-').replace(':', '-')
            
            # Format steps
            steps_formatted = []
            for i, step in enumerate(workflow.steps, 1):
                # Try to find matching command
                matching_cmd = self._find_matching_command(step, commands)
                if matching_cmd:
                    steps_formatted.append(f"{i}. {step} (`{matching_cmd.command}`)")
                else:
                    steps_formatted.append(f"{i}. {step}")
            
            content = f"""---
name: {name}
description: {workflow.description}
source: {workflow.source}
---

# {name.replace('-', ' ').title()} Workflow

## Description
{workflow.description}

## Source
Extracted from: `{workflow.source}`

{f"## Triggers{chr(10)}{chr(10).join(f'- {t}' for t in workflow.triggers)}" if workflow.triggers else ''}

## Steps
{chr(10).join(steps_formatted)}

## Usage
This workflow {self._determine_workflow_usage(workflow)}

## Related Commands
{self._find_workflow_commands(workflow, commands)}

## Notes
{self._generate_workflow_notes(workflow)}
"""
            
            workflow_files.append(WorkflowFile(
                name=safe_name,
                content=content,
                path=self.claude_dir / "workflows" / f"{safe_name}.md"
            ))
        
        # Create additional common workflows if not present
        if 'development' not in workflows:
            dev_workflow = self._create_development_workflow(commands)
            if dev_workflow:
                workflow_files.append(dev_workflow)
        
        if 'testing' not in workflows:
            test_workflow = self._create_testing_workflow(commands)
            if test_workflow:
                workflow_files.append(test_workflow)
        
        return workflow_files
    
    def write_context_files(self,
                           claude_md: str,
                           module_claude_mds: Any,  # Can be dict or list of tuples
                           command_files: List[CommandFile],
                           agent_files: List[AgentFile],
                           workflow_files: List[WorkflowFile]) -> Dict[str, Any]:
        """
        Write all context files to disk
        """
        results = {
            'created_files': [],
            'errors': [],
            'summary': {}
        }
        
        try:
            # Write root CLAUDE.md
            claude_md_path = self.project_path / "CLAUDE.md"
            with open(claude_md_path, 'w', encoding='utf-8') as f:
                f.write(claude_md)
            results['created_files'].append(str(claude_md_path))
            
            # Write module CLAUDE.md files
            # Handle both dict and list of tuples
            if isinstance(module_claude_mds, dict):
                items = module_claude_mds.items()
            else:
                items = module_claude_mds
            
            for module, content in items:
                module_claude_path = module.path / "CLAUDE.md"
                module_claude_path.parent.mkdir(parents=True, exist_ok=True)
                with open(module_claude_path, 'w', encoding='utf-8') as f:
                    f.write(content)
                results['created_files'].append(str(module_claude_path))
            
            # Create .claude/ directory structure
            (self.claude_dir / "commands").mkdir(parents=True, exist_ok=True)
            (self.claude_dir / "agents").mkdir(parents=True, exist_ok=True)
            (self.claude_dir / "workflows").mkdir(parents=True, exist_ok=True)
            
            # Write command files
            for cmd_file in command_files:
                with open(cmd_file.path, 'w', encoding='utf-8') as f:
                    f.write(cmd_file.content)
                results['created_files'].append(str(cmd_file.path))
            
            # Write agent files
            for agent_file in agent_files:
                with open(agent_file.path, 'w', encoding='utf-8') as f:
                    f.write(agent_file.content)
                results['created_files'].append(str(agent_file.path))
            
            # Write workflow files
            for workflow_file in workflow_files:
                with open(workflow_file.path, 'w', encoding='utf-8') as f:
                    f.write(workflow_file.content)
                results['created_files'].append(str(workflow_file.path))
            
            # Create summary
            module_count = len(module_claude_mds) if isinstance(module_claude_mds, (dict, list)) else 0
            results['summary'] = {
                'root_claude_md': 1,
                'module_claude_mds': module_count,
                'commands': len(command_files),
                'agents': len(agent_files),
                'workflows': len(workflow_files),
                'total_files': len(results['created_files'])
            }
            
        except Exception as e:
            results['errors'].append(str(e))
            # Create default summary even on error
            if 'summary' not in results:
                results['summary'] = {
                    'root_claude_md': 0,
                    'module_claude_mds': 0,
                    'commands': 0,
                    'agents': 0,
                    'workflows': 0,
                    'total_files': 0,
                    'error': str(e)
                }
        
        return results
    
    # Helper methods
    
    def _generate_quick_start(self, project_info: ProjectInfo, commands: Dict[str, Command]) -> str:
        """Generate quick start section"""
        steps = []
        
        # Look for setup/install commands
        for cmd_name, cmd in commands.items():
            if cmd.category == 'setup' or 'install' in cmd_name.lower():
                steps.append(f"1. Install dependencies: `{cmd.command}`")
                break
        
        # Look for dev/start commands
        for cmd_name, cmd in commands.items():
            if cmd.category == 'dev' or 'start' in cmd_name.lower():
                steps.append(f"2. Start development: `{cmd.command}`")
                break
        
        # Look for test commands
        for cmd_name, cmd in commands.items():
            if cmd.category == 'test':
                steps.append(f"3. Run tests: `{cmd.command}`")
                break
        
        return '\n'.join(steps) if steps else "1. Clone repository\n2. Install dependencies\n3. Start development"
    
    def _list_module_contexts(self, modules: List[Module]) -> str:
        """List module contexts"""
        if not modules:
            return "- No module-specific contexts created"
        
        lines = []
        for module in modules[:5]:  # List first 5
            rel_path = module.path.relative_to(self.project_path)
            lines.append(f"- `{rel_path}/CLAUDE.md` - {module.description}")
        
        if len(modules) > 5:
            lines.append(f"- ... and {len(modules) - 5} more modules")
        
        return '\n'.join(lines)
    
    def _generate_testing_section(self, commands: Dict[str, Command]) -> str:
        """Generate testing section"""
        test_commands = [cmd for cmd in commands.values() if cmd.category == 'test']
        
        if not test_commands:
            return "No test commands detected. Add test scripts to your project."
        
        lines = ["Run tests using:"]
        for cmd in test_commands[:3]:
            lines.append(f"- `{cmd.command}` - {cmd.description}")
        
        return '\n'.join(lines)
    
    def _generate_deployment_section(self, commands: Dict[str, Command]) -> str:
        """Generate deployment section"""
        deploy_commands = [cmd for cmd in commands.values() if cmd.category == 'deploy']
        
        if not deploy_commands:
            return "No deployment commands detected. See workflows for deployment process."
        
        lines = ["Deploy using:"]
        for cmd in deploy_commands[:3]:
            lines.append(f"- `{cmd.command}` - {cmd.description}")
        
        return '\n'.join(lines)
    
    def _generate_module_tasks(self, module: Module) -> str:
        """Generate common tasks for a module"""
        tasks = []
        
        if module.has_tests:
            tasks.append("- Run module tests")
        
        tasks.extend([
            "- Add new features",
            "- Fix bugs",
            "- Refactor code",
            "- Update documentation"
        ])
        
        return '\n'.join(tasks)
    
    def _generate_integration_points(self, module: Module) -> str:
        """Generate integration points for a module"""
        # This would need more sophisticated analysis
        return "- Integrates with other modules through defined interfaces\n- See project architecture for details"
    
    def _generate_development_notes(self, module: Module) -> str:
        """Generate development notes for a module"""
        notes = []
        
        if module.has_tests:
            notes.append("- This module has its own test suite")
        
        if module.has_docs:
            notes.append("- Additional documentation available in module")
        
        if module.dependencies:
            notes.append(f"- Uses {len(module.dependencies)} specific dependencies")
        
        return '\n'.join(notes) if notes else "- Follow project-wide development guidelines"
    
    def _analyze_command_parameters(self, command: str) -> bool:
        """Check if command likely needs parameters"""
        param_indicators = ['$', '<', '>', '[', ']', '{', '}']
        return any(indicator in command for indicator in param_indicators)
    
    def _generate_command_details(self, cmd: Command) -> str:
        """Generate additional command details"""
        details = []
        
        if 'npm' in cmd.command or 'yarn' in cmd.command:
            details.append("## Prerequisites\n- Node.js and npm/yarn installed")
        elif 'python' in cmd.command or 'pip' in cmd.command:
            details.append("## Prerequisites\n- Python installed")
        elif 'docker' in cmd.command:
            details.append("## Prerequisites\n- Docker installed and running")
        
        return '\n\n'.join(details) if details else ""
    
    def _generate_command_examples(self, name: str, cmd: Command, needs_params: bool) -> str:
        """Generate command examples"""
        if not needs_params:
            return ""
        
        return f"""## Examples
```bash
# Basic usage
{cmd.command}

# With options (if applicable)
{cmd.command} --verbose
```"""
    
    def _find_related_commands(self, name: str, cmd: Command, all_commands: Dict[str, Command]) -> str:
        """Find related commands"""
        related = []
        
        for other_name, other_cmd in all_commands.items():
            if other_name != name and other_cmd.category == cmd.category:
                related.append(f"- `/{other_name}` - {other_cmd.description}")
        
        return '\n'.join(related[:3]) if related else "- No related commands"
    
    def _determine_agent_tools(self, module: Module) -> List[str]:
        """Determine appropriate tools for an agent based on module"""
        # All agents get basic tools
        tools = ['Read', 'Write', 'Edit']
        
        # Add tools based on module characteristics
        if module.has_tests:
            tools.append('Bash')  # For running tests
        
        if module.name in ['api', 'server', 'backend']:
            tools.extend(['Bash', 'Grep'])  # For server operations
        
        if module.name in ['database', 'db', 'models']:
            tools.append('Bash')  # For database operations
        
        # Ensure no duplicates
        return list(dict.fromkeys(tools))
    
    def _generate_agent_responsibilities(self, module: Module) -> str:
        """Generate agent responsibilities based on module"""
        base_responsibilities = [
            f"- Maintain and improve code in the {module.name} module",
            "- Ensure code quality and consistency",
            "- Write and update tests",
            "- Fix bugs and implement features"
        ]
        
        # Add specific responsibilities based on module type
        if 'auth' in module.name.lower():
            base_responsibilities.append("- Handle authentication and authorization logic")
        elif 'api' in module.name.lower():
            base_responsibilities.append("- Manage API endpoints and middleware")
        elif 'database' in module.name.lower() or 'model' in module.name.lower():
            base_responsibilities.append("- Manage data models and database operations")
        
        return '\n'.join(base_responsibilities)
    
    def _generate_agent_operations(self, module: Module) -> str:
        """Generate common operations for an agent"""
        operations = [
            f"- Add new features to {module.name}",
            f"- Debug issues in {module.name}",
            f"- Refactor {module.name} code",
            f"- Update {module.name} documentation"
        ]
        
        if module.test_command:
            operations.append(f"- Run tests: `{module.test_command}`")
        
        return '\n'.join(operations)
    
    def _find_matching_command(self, step: str, commands: Dict[str, Command]) -> Optional[Command]:
        """Find a command that matches a workflow step"""
        step_lower = step.lower()
        
        for name, cmd in commands.items():
            if name.lower() in step_lower or cmd.command.lower() in step_lower:
                return cmd
        
        return None
    
    def _determine_workflow_usage(self, workflow: Workflow) -> str:
        """Determine how a workflow is typically used"""
        if workflow.triggers:
            trigger_text = ', '.join(workflow.triggers)
            return f"is triggered by: {trigger_text}"
        elif 'ci' in workflow.name.lower() or 'cd' in workflow.name.lower():
            return "runs automatically in CI/CD"
        else:
            return "is run manually when needed"
    
    def _find_workflow_commands(self, workflow: Workflow, commands: Dict[str, Command]) -> str:
        """Find commands related to a workflow"""
        related = []
        
        for step in workflow.steps:
            cmd = self._find_matching_command(step, commands)
            if cmd and cmd.command not in [r for r in related]:
                related.append(f"- `{cmd.command}` - {cmd.description}")
        
        return '\n'.join(related[:5]) if related else "- No specific commands identified"
    
    def _generate_workflow_notes(self, workflow: Workflow) -> str:
        """Generate notes for a workflow"""
        notes = []
        
        if 'github' in workflow.source.lower():
            notes.append("- This workflow runs on GitHub Actions")
        elif 'jenkins' in workflow.source.lower():
            notes.append("- This workflow runs on Jenkins")
        elif 'gitlab' in workflow.source.lower():
            notes.append("- This workflow runs on GitLab CI")
        
        if len(workflow.steps) > 10:
            notes.append(f"- Complex workflow with {len(workflow.steps)} steps")
        
        return '\n'.join(notes) if notes else "- Standard workflow for this project"
    
    def _create_development_workflow(self, commands: Dict[str, Command]) -> Optional[WorkflowFile]:
        """Create a standard development workflow if not present"""
        steps = []
        
        # Find relevant commands
        for cmd in commands.values():
            if cmd.category == 'setup' and len(steps) == 0:
                steps.append(f"Install dependencies (`{cmd.command}`)")
            elif cmd.category == 'dev' and len(steps) == 1:
                steps.append(f"Start development server (`{cmd.command}`)")
            elif cmd.category == 'test' and len(steps) == 2:
                steps.append(f"Run tests (`{cmd.command}`)")
        
        if not steps:
            return None
        
        # Add generic steps if missing
        if len(steps) == 0:
            steps.append("Install project dependencies")
        if len(steps) == 1:
            steps.append("Start development environment")
        if len(steps) == 2:
            steps.append("Run tests to verify changes")
        
        steps.append("Make code changes")
        steps.append("Test your changes")
        steps.append("Commit changes")
        
        content = f"""---
name: development
description: Standard development workflow
source: Generated by SubForge
---

# Development Workflow

## Description
Standard workflow for developing features and fixes

## Steps
{chr(10).join(f'{i}. {step}' for i, step in enumerate(steps, 1))}

## Best Practices
- Always run tests before committing
- Follow project conventions
- Update documentation as needed
- Create feature branches for new work

## Related Commands
- See `/dev` commands for development
- See `/test` commands for testing
- See `/build` commands for building
"""
        
        return WorkflowFile(
            name="development",
            content=content,
            path=self.claude_dir / "workflows" / "development.md"
        )
    
    def _create_testing_workflow(self, commands: Dict[str, Command]) -> Optional[WorkflowFile]:
        """Create a standard testing workflow if not present"""
        test_commands = [cmd for cmd in commands.values() if cmd.category == 'test']
        
        if not test_commands:
            return None
        
        steps = []
        for cmd in test_commands[:5]:
            steps.append(f"Run {cmd.description} (`{cmd.command}`)")
        
        content = f"""---
name: testing
description: Standard testing workflow
source: Generated by SubForge
---

# Testing Workflow

## Description
Complete testing workflow for the project

## Steps
{chr(10).join(f'{i}. {step}' for i, step in enumerate(steps, 1))}

## Testing Strategy
- Run unit tests first (fastest)
- Then integration tests
- Finally end-to-end tests (if available)

## Coverage
Ensure adequate test coverage for:
- New features
- Bug fixes
- Edge cases
- Error handling

## Related Commands
{chr(10).join(f'- `{cmd.command}` - {cmd.description}' for cmd in test_commands[:5])}
"""
        
        return WorkflowFile(
            name="testing",
            content=content,
            path=self.claude_dir / "workflows" / "testing.md"
        )


# Simple test function
if __name__ == "__main__":
    import sys
    from .knowledge_extractor import ProjectKnowledgeExtractor
    
    if len(sys.argv) > 1:
        project_path = sys.argv[1]
    else:
        project_path = os.getcwd()
    
    print(f"Building context for: {project_path}\n")
    
    # Extract knowledge
    extractor = ProjectKnowledgeExtractor(project_path)
    project_info = extractor.extract_project_info()
    commands = extractor.extract_commands()
    workflows = extractor.extract_workflows()
    modules = extractor.identify_modules()
    
    # Build context
    builder = ContextBuilder(project_path)
    
    # Build CLAUDE.md
    claude_md = builder.build_root_claude_md(project_info, modules, commands)
    print("Built root CLAUDE.md")
    
    # Build module CLAUDE.mds
    module_claude_mds = {}
    for module in modules:
        module_claude_mds[module] = builder.build_module_claude_md(module, project_info)
    print(f"Built {len(module_claude_mds)} module CLAUDE.md files")
    
    # Build command files
    command_files = builder.build_command_files(commands)
    print(f"Built {len(command_files)} command files")
    
    # Build agent files
    agent_files = builder.build_agent_files(modules, project_info)
    print(f"Built {len(agent_files)} agent files")
    
    # Build workflow files
    workflow_files = builder.build_workflow_files(workflows, commands)
    print(f"Built {len(workflow_files)} workflow files")
    
    print("\nReady to write files. Use write_context_files() to create them.")